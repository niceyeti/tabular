/*
FastView is a small ui library for rapid development of realtime, readonly html visualizations.
It uses html/template to spin up views from models and pushes updates to the via websocket.
*/
package fastview

type Model [T any]struct {
	source chan T
}

func (m *Model) As[T1 any, T2 any](func(T1) T2) *Model {

}

/*cell_views, cell_ele_updates := Model(chan [][]State) // some/any model exposing derivations from the incoming States
			.Transform()
            	.As(state -> Cell) // convert the data to a target type for these views
            .Views()
				.WithView(cell_chan -> NewValuesGridView(cell_chan))   // build the grid-view
				.WithView(cell_chan -> NewValueFuncView(cell_chan))    // build the value function view
				.Build() //Terminal call: returns views and ele_update chans*/

	// Single struct type attempt. Here, lib users can only convert from T1 to T2, and T2's are passed into the views.
	// They may build multiple views that consume T2's, by way of a broadcast. Build() returns the views and []EleUpdate chan.
	// This version encapsulates views by a single target model (T2 type), such as Cell. View code can then be organized in
	// packages per these types; callers of Build() are in control of the layout of each view returned. View composition is
	// supported, whereby the output @target could be passed as input to another builder.
	type ViewBuilder[T1 any, T2 any] struct {
		source chan T1   // The source type of data, e.g. [][]State
		target chan T2   // The target data type, e.g. [][]Cell, State -> Cell
		views []View     // The set of views (implementing )
		updates chan []EleUpdate  // All of the View ele-update chans fanned into a single channel of values to send to client
	}
	// Methods:
	//     NewViewBuilder[T1, T2](source chan T1) *ViewBuilder
	//     vb.WithModel(func([]T1) []T2)
	//     vb.WithView(chan []T2 -> NewValuesGridView(t2_chan))
	//     vb.Build()  <- execute the builder to get views and ele-update chan; delaying execution of stored funcs allows setting up multiplexing
	//						of the @target channel to potentially several view listeners 
	//
	//	Example usage:
	//		vb := NewViewBuilder[State, Cell](raw_data_chan) // Pass some data chan representing the source-domain (State or other algorithmic data structures)
	//      vb.WithModel(convertFunc)  // Convert the source data to models useful to views. This populates @target. Only a single data conversion is allowed.
	//		vb.WithView(target -> NewValuesGrid(target)) // Add one or several views to which the target models will be broadcast
	//      vb.WithView(target -> NewValuesFunc(target))
	//		views, ele_updates, err := vb.Build() // Build executes all of the previous builder funcs; (views, ele_updates) might be a type
	//
	//
	// Evaluation:
	// - does this meet requirements? I like this form because it constricts a ViewBuilder to a single data-type conversion, and thus a single
	//   view-model bound to a set of views. This is natural since it makes the view-model central to the creation of views. There is potential
	//   for recursive construction (a ViewBuilder defined within another), but its probably beyond scope. Index.html builder could 
	// - is it testable? robust? maintainability?
	//   * testable: there is not much to test, except data broadcasting
	//   * robust: I think so... this makes the view model the unit of development for new views, and their code lives in separate files.
	//   * maintainable: to implement a new view, developer only needs to implement convertFunc and NewFooView for each view thereof.
    // - what kind of page semantics are supported? A single open page, or several?
	//   The ViewBuilder is built/executed in the Server constructor, thus the views and ele-updates channel is already configured.
	//   When index-endpoint is hit, a new page is written, and a hit to /ws occurs for a new websocket. The views write their
	//   templates to the index.html requested by the client; the only remaining responsibilities then are multipexing the ele-updates
	//   to all open web-sockets. Currently the relationship of ele-updates to sockets is 1:1, but will therefore need to be 1:n and
	//   will also need to incorporate socket closure per client.





	type FastView {
		chan interface{}
		views []View
		clientUpdates chan []EleUpdate
	}

	type View {
		Init(io.Writer)
	}

	type ViewBuilder struct {
		fastView *FastView
	}

	func NewViewBuilder() *ViewBuilder {
		return &ViewBuilder{
			fastView: &ViewBuilder{},
		}
	}

	func (vb *ViewBuilder) Build() *FastView {
		return vb.fastView
	}

	func (vb *ViewBuilder) Convert()

	func (vb *ViewBuilder) As(func() )



			package main

			import "fmt"
			
			type Person struct {
			  StreetAddress, Postcode, City string
			  CompanyName, Position string
			  AnnualIncome int
			}
			
			type PersonBuilder struct {
			  person *Person // needs to be inited
			}
			
			func NewPersonBuilder() *PersonBuilder {
			  return &PersonBuilder{&Person{}}
			}
			
			func (it *PersonBuilder) Build() *Person {
			  return it.person
			}
			
			func (it *PersonBuilder) Works() *PersonJobBuilder {
			  return &PersonJobBuilder{*it}
			}
			
			func (it *PersonBuilder) Lives() *PersonAddressBuilder {
			  return &PersonAddressBuilder{*it}
			}
			
			type PersonJobBuilder struct {
			  PersonBuilder
			}
			
			func (pjb *PersonJobBuilder) At(
			  companyName string) *PersonJobBuilder {
			  pjb.person.CompanyName = companyName
			  return pjb
			}
			
			func (pjb *PersonJobBuilder) AsA(
			  position string) *PersonJobBuilder {
			  pjb.person.Position = position
			  return pjb
			}
			
			func (pjb *PersonJobBuilder) Earning(
			  annualIncome int) *PersonJobBuilder {
			  pjb.person.AnnualIncome = annualIncome
			  return pjb
			}
			
			type PersonAddressBuilder struct {
			  PersonBuilder
			}
			
			func (it *PersonAddressBuilder) At(
			  streetAddress string) *PersonAddressBuilder {
			  it.person.StreetAddress = streetAddress
			  return it
			}
			
			func (it *PersonAddressBuilder) In(
			  city string) *PersonAddressBuilder {
			  it.person.City = city
			  return it
			}
			
			func (it *PersonAddressBuilder) WithPostcode(
			  postcode string) *PersonAddressBuilder {
			  it.person.Postcode = postcode
			  return it
			}
			
			func main() {
			  pb := NewPersonBuilder()
			  pb.
				Lives().
				  At("123 London Road").
				  In("London").
				  WithPostcode("SW12BC").
				Works().
				  At("Fabrikam").
				  AsA("Programmer").
				  Earning(123000)
			  person := pb.Build()
			  fmt.Println(*person)
			}
